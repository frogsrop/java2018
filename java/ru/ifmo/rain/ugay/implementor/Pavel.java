
        package ru.ifmo.rain.ugay.implementor;

        import info.kgeorgiy.java.advanced.implementor.Impler;
        import info.kgeorgiy.java.advanced.implementor.ImplerException;

        import javax.annotation.processing.Completion;
        import java.io.BufferedWriter;
        import java.io.File;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.OutputStreamWriter;
        import java.lang.reflect.Constructor;
        import java.lang.reflect.Executable;
        import java.lang.reflect.Method;
        import java.lang.reflect.Modifier;
        import java.lang.reflect.Parameter;
        import java.nio.file.Files;
        import java.nio.file.Path;
        import java.util.ArrayList;
        import java.util.Arrays;
        import java.util.Comparator;
        import java.util.HashSet;
        import java.util.Objects;
        import java.util.Set;
        import java.util.TreeSet;
        import java.util.function.BiConsumer;
        import java.util.function.Function;
        import java.util.function.Supplier;
        import java.util.stream.Collectors;

public class Pavel implements Impler {

    private String getClassName(Class<?> aClass) {
        return aClass.getSimpleName() + "Impl";
    }

    private String getDefaultValue(Class<?> aClass) {
        if (aClass.equals(boolean.class)) {
            return " false";
        } else if (aClass.equals(void.class)) {
            return "";
        } else if (aClass.isPrimitive()) {
            return " 0";
        } else {
            return " null";
        }
    }

    private final static String TAP = "    ";
    private final static String SPC = " ";
    private final static String ESC = System.lineSeparator();
    private final static String COMMA = ",";
    private final static String SEMI = ";";
    private final static String BRl = "(";
    private final static String BRr = ")";
    private final static String CBRl = "{";
    private final static String CBRr = "}";

    private String genHead(Class<?> aClass) {
        StringBuilder result = new StringBuilder();
        result.append("//This code was generated by Implementor class." + ESC + ESC);
        if (aClass.getPackage() != null) {
            result.append("package" + SPC + aClass.getPackage().getName() + SEMI + ESC + ESC);
        }
        result.append("public" + SPC + "class" + SPC + getClassName(aClass) + SPC +
                (aClass.isInterface() ? "implements" : "extends") + SPC + aClass.getSimpleName() + SPC + CBRl + ESC);
        return result.toString();
    }

    private String genTail(Class<?> aClass) { // must be consistent with genHead()
        return CBRr;
    }

    private void addToMethodStorage(Method[] methods, Set<Method> storage) {
        Arrays.stream(methods)
                .filter(method -> Modifier.isAbstract(method.getModifiers()))
                .collect(Collectors.toCollection(() -> storage));
    }

    private String genAbstractMethods(Class<?> aClass) {
        StringBuilder result = new StringBuilder();

        Set<Method> methods = new TreeSet<>(Comparator.comparingInt(
                method -> (method.getName() + Arrays.toString(method.getParameterTypes())).hashCode()));

        addToMethodStorage(aClass.getMethods(), methods);
        for (Class<?> token = aClass; token != null; token = token.getSuperclass()) {
            addToMethodStorage(token.getDeclaredMethods(), methods);
        }

        for (Method method : methods) {
            result.append(genExecutable(method, method.getReturnType().getCanonicalName(), method.getName()));
            result.append(TAP + TAP + "return" + getDefaultValue(method.getReturnType()) + SEMI + ESC);
            result.append(TAP + CBRr + ESC);
            result.append(ESC);
        }

        return result.toString();
    }

    private String genConstructors(Class<?> aClass) {
        StringBuilder result = new StringBuilder();
        if (!aClass.isInterface()) {
            for(Constructor constructor: aClass.getDeclaredConstructors()) {
                if (!Modifier.isPrivate(constructor.getModifiers())) {
                    result.append(genExecutable(constructor, "", getClassName(aClass)));
                    result.append(TAP + TAP + "super");
                    result.append(Arrays.stream(constructor.getParameters()).map(Parameter::getName)
                            .collect(Collectors.joining(COMMA + SPC, BRl, BRr)) + SEMI + ESC);
                    result.append(TAP + CBRr + ESC);
                    result.append(ESC);
                }
            }
        }
        return result.toString();
    }


    private String genExecutable(Executable func, String returnType, String funcName) {
        StringBuilder result = new StringBuilder();

        result.append(TAP + Modifier.toString(func.getModifiers()).replaceAll("abstract|transient|volatile|native", ""));
        result.append(returnType + SPC);
        result.append(funcName);
        result.append(genParametersExecutable(func) + SPC);
        result.append(genExceptionExecutable(func) + CBRl + ESC);
        return result.toString();
    }

    private String genParametersExecutable(Executable func) {
        return Arrays.stream(func.getParameters())
                .map(parameter -> parameter.getType().getCanonicalName() + SPC + parameter.getName())
                .collect(Collectors.joining(COMMA + SPC, BRl, BRr));
    }

    private String genExceptionExecutable(Executable func) {
        if (func.getExceptionTypes().length == 0)
            return "";
        else
            return Arrays.stream(func.getExceptionTypes())
                    .map(Class::getCanonicalName)
                    .collect(Collectors.joining(COMMA + SPC, "throws" + SPC, SPC));
    }

    /**
     * Produces code implementing class or interface specified by provided <tt>token</tt>.
     * <p>
     * Generated class full name should be same as full name of the type token with <tt>Impl</tt> suffix
     * added. Generated source code should be placed in the correct subdirectory of the specified
     * <tt>root</tt> directory and have correct file name. For example, the implementation of the
     * interface {@link java.util.List} should go to <tt>$root/java/util/ListImpl.java</tt>
     *
     * @param token type token to create implementation for.
     * @param root  root directory.
     * @throws info.kgeorgiy.java.advanced.implementor.ImplerException when implementation cannot be
     *                                                                 generated.
     */
    @Override
    public void implement(Class<?> token, Path root) throws ImplerException {
        Objects.requireNonNull(token);
        Objects.requireNonNull(root);
        if (token.isPrimitive() || token.isArray() || Modifier.isFinal(token.getModifiers()) || token == Enum.class) {
            throw new ImplerException("Incorrect type");
        }

        try (BufferedWriter code = createFile(token, root)) {
            try {
                code.write(genHead(token) + ESC);
                System.out.println(genHead(token) + ESC);
                if (!token.isInterface()) {
                    if (genConstructors(token).isEmpty())
                        throw new ImplerException("Couldn't access constructors of super class");
                    code.write(genConstructors(token));
                    System.out.println(genConstructors(token));
                }
                code.write(genAbstractMethods(token));
                System.out.println(genAbstractMethods(token));
                code.write(genTail(token));
                System.out.println(genTail(token));
            } catch (IOException e) {
                throw new ImplerException("Problems with writing file.", e);
            }
        } catch (IOException e) {
            throw new ImplerException("Problems with create or close.", e);
        }
    }

    private BufferedWriter createFile(Class<?> token, Path path) throws IOException {
        Path pathFile = path.resolve(token.getCanonicalName().replace('.', File.separatorChar) + "Impl.java");
        Files.createDirectories(Objects.requireNonNull(pathFile.getParent()));
        Files.deleteIfExists(pathFile); //TODO
        Files.createFile(pathFile);
        return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(pathFile.toString()), "UTF8"));
    }


    public static void main(String[] args) {
        //TODO4
    }
}
